<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>vb_index.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>vb_index.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <p>vim:fenc=utf-8</p>
<p>Copyright Â© 2022 VB Index Team</p>
<p>Distributed under terms of the GNU license.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">nibabel</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">textwrap</span> <span class="k">as</span> <span class="nn">_textwrap</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">spl</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">lobpcg</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">ipdb</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>It is responsible for executing the functions in the correct order to achieve the final result.</p>
<h2>Parameters</h2>
<p>internal_loop_func : string
    The function that is going to run depending on the analysis to be done.
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
surf_faces : numpy array (M, 3)
    Faces of the mesh. Used to find the neighborhood of a given vertex.
n_cpus : integer
    How many CPU cores are available.
data : numpy array (M, N)
    Data to use to calculate the VB index. M must match the number of vertices in the mesh.
norm : string
    Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;.
residual_tolerance : string
    ?????????????????
max_num_iter : integer
    Number of iterations for eigenpair calculation.
output_name : string, optional
    Name of the output file(s). The default is None.
nib_surf : nibabel object, optional
    Nibabel object containing metadata to be replicated. The default is None.
k : integer, optional
    Factor determining increase in density of input mesh. The default is None.
cluster_index : numpy array (M,), optional
   Array containing the cluster which each vertex belongs to. The default is None.
cort_index : numpy array (M,), optional
    Mask for detection of middle brain structures. The default is None.
affine : ??????????, optional
    ?????????????. The default is None.
debug : boolean, optional
    Outputs ribbon file for debugging. The default is False.</p>
<h2>Returns</h2>
<p>processed_results : Full brain -&gt; Tuple (numpy array, numpy array)
                    Searchlight -&gt; numpy array of float32 (M,)
                    Hybrid -&gt; ?????????
    It stores the results, either the eigenvalue or the eigenpair.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">compute_vb_metrics</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nib_surf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cort_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">func_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;vb_cluster&quot;</span><span class="p">:</span> <span class="s2">&quot;vb_cluster_internal_loop&quot;</span><span class="p">,</span>
        <span class="s2">&quot;vb_index&quot;</span><span class="p">:</span> <span class="s2">&quot;vb_index_internal_loop&quot;</span>
    <span class="p">}</span>
    <span class="n">internal_loop_func</span> <span class="o">=</span> <span class="n">func_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="s2">&quot;vb_hybrid_internal_loop&quot;</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>Determine n_items and n_cpus</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">n_items</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">,</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">determine_items_and_cpus</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <p>Initialize multiprocessing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">pool</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">initialize_multiprocessing</span><span class="p">(</span><span class="n">n_cpus</span><span class="p">,</span> <span class="n">n_items</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      <p>Run multiprocessing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">results</span> <span class="o">=</span> <span class="n">run_multiprocessing</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">n_items</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <p>Process and save results</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">processed_results</span> <span class="o">=</span> <span class="n">process_and_save_results</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_items</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      <p>Clean up</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">cleanup</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <p>Return results</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">return</span> <span class="n">processed_results</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      <p>Divides and parallelizes a job according to the number of CPUs available</p>
<h2>Parameters</h2>
<p>internal_loop_func : string
    The function that is going to run depending on the analysis to be done.
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
cluster_index : numpy array (M,)
    Indicates to which cluster each vertex belongs.
n_cpus : integer
    How many CPU cores are available.</p>
<h2>Returns</h2>
<p>n_items : integer
    How many clusters are.
n_cpus : integer
    How many CPU cores are going to be used.
dn : integer
    How many elements will be processed for each CPU.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">determine_items_and_cpus</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    
    <span class="k">if</span> <span class="n">internal_loop_func</span> <span class="o">==</span> <span class="s2">&quot;vb_cluster_internal_loop&quot;</span><span class="p">:</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_index</span><span class="p">)</span>
        <span class="n">n_items</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_items</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf_vertices</span><span class="p">)</span>
    
    <span class="n">n_cpus</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_items</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">)</span>
    <span class="n">dn</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_items</span> <span class="o">//</span> <span class="n">n_cpus</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Ensure at least one item per CPU</span>
    <span class="k">return</span> <span class="n">n_items</span><span class="p">,</span> <span class="n">n_cpus</span><span class="p">,</span> <span class="n">dn</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      <p>It initializes the multiprocessing threads.</p>
<h2>Parameters</h2>
<p>n_cpus : integer
    How many CPU cores are going to be used.
n_items : integer
    How many clusters are.</p>
<h2>Returns</h2>
<p>pool : ????????
    ???????.
counter : ???????
    ?????????.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">initialize_multiprocessing</span><span class="p">(</span><span class="n">n_cpus</span><span class="p">,</span> <span class="n">n_items</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">counter</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">n_cpus</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">n_items</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pool</span><span class="p">,</span> <span class="n">counter</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-13'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-13'>#</a>
      </div>
      <p>Initializes the specific function for each analysis and takes care of multiprocessing.</p>
<h2>Parameters</h2>
<p>pool : ??????????
    ????????.
internal_loop_func : string
    The function that is going to run depending on the analysis to be done.
n_items : integer
    How many clusters are.
dn : integer
    How many elements will be processed for each CPU.
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
surf_faces : numpy array (M, 3)
    Faces of the mesh. Used to find the neighborhood of a given vertex.
data : numpy array (M, N)
    Data to use to calculate the VB index. M must match the number of vertices in the mesh.
norm : string
    Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;.
residual_tolerance : string
    ?????????.
max_num_iter : integer
    Number of iterations for eigenpair calculation.
cluster_index : numpy array (M,)
    Array containing the cluster which each vertex belongs to.
cort_index : numpy array (M,)
    Mask for detection of middle brain structures.
affine : ??????????
    ??????????.
k : integer
    Factor determining increase in density of input mesh.
debug : boolean
    Outputs ribbon file for debugging.</p>
<h2>Returns</h2>
<p>t.get(): numpy array.
    It gets the results of all the threads.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">run_multiprocessing</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">n_items</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">debug</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-14'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-14'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">def</span> <span class="nf">pool_callback</span><span class="p">(</span><span class="n">result</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-15'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-15'>#</a>
      </div>
      <p>Define error handling here</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error occurred in pool execution:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-16'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-16'>#</a>
      </div>
      <p>Terminate the pool in case of error</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
    
    <span class="n">full_brain</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_items</span><span class="p">,</span> <span class="n">dn</span><span class="p">):</span>
        <span class="n">iN</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="n">dn</span><span class="p">,</span> <span class="n">n_items</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">internal_loop_func</span> <span class="o">==</span> <span class="s2">&quot;vb_cluster_internal_loop&quot;</span><span class="p">:</span>
            <span class="n">threads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threads</span><span class="p">,</span> <span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">vb_cluster_internal_loop</span><span class="p">,</span> <span class="p">(</span><span class="n">full_brain</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">pool_callback</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">internal_loop_func</span> <span class="o">==</span> <span class="s2">&quot;vb_hybrid_internal_loop&quot;</span><span class="p">:</span>
            <span class="n">threads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threads</span><span class="p">,</span> <span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">vb_hybrid_internal_loop</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">debug</span><span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">pool_callback</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">threads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threads</span><span class="p">,</span> <span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">vb_index_internal_loop</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">),</span> <span class="n">error_callback</span><span class="o">=</span><span class="n">pool_callback</span><span class="p">)))</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-17'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-17'>#</a>
      </div>
      <p>Wait for all threads to complete</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">threads</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">threads</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> 

    <span class="k">return</span> <span class="n">res</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-18'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-18'>#</a>
      </div>
      <p>It contains the logic to process the results depending on the desired analysis</p>
<h2>Parameters</h2>
<p>internal_loop_func : string
    The function that is going to run depending on the analysis to be done.
results : numpy array (M,)
    The results of all the threads.
output_name : string
    Name of the output file(s).
nib_surf : nibabel object
    Nibabel object containing metadata to be replicated.
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
cluster_index : numpy array (M,)
    Array containing the cluster which each vertex belongs to.
cort_index : numpy array (M,)
    Mask for detection of middle brain structures.
affine : ??????????
    ??????????.
debug : boolean
    Outputs ribbon file for debugging.
data : numpy array (M, N)
    Data to use to calculate the VB index. M must match the number of vertices in the mesh.
n_items : integer
    How many clusters are. </p>
<h2>Returns</h2>
<p>Full-brain -&gt; results_eigenvalues : numpy array (M, )
                  Array of the same size as the eigenvectors array but only containing
                  the eigenvalue(s).
              results_eigenvectors : numpy array (M, 1)
                  Array with the same size as the eigenvalues array, each column corresponds
                  to each value.</p>
<p>Searchlight -&gt; results_v2 : numpy array (M, )
                   Array of the computed eigenvalues.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">process_and_save_results</span><span class="p">(</span><span class="n">internal_loop_func</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_items</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-19'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-19'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-20'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-20'>#</a>
      </div>
      <p>Implement the processing of results and saving of files as needed.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="n">internal_loop_func</span> <span class="o">==</span> <span class="s2">&quot;vb_cluster_internal_loop&quot;</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-21'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-21'>#</a>
      </div>
      <p>Processing for vb_cluster_internal_loop
Replicating the logic from the old code to handle eigenvalues and eigenvectors</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">return</span> <span class="n">process_vb_cluster_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">n_items</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">internal_loop_func</span> <span class="o">==</span> <span class="s2">&quot;vb_index_internal_loop&quot;</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-22'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-22'>#</a>
      </div>
      <p>Processing for vb_index_internal_loop
This should handle the results specifically for vb_index_internal_loop</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">return</span> <span class="n">process_vb_index_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-23'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-23'>#</a>
      </div>
      <p>Processing for vb_hybrid_internal_loop
This should handle the results specifically for vb_hybrid_internal_loop</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">return</span> <span class="n">process_vb_hybrid_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-24'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-24'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-25'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-25'>#</a>
      </div>
      <p>It processes the results obtained from the vb_cluster_internal_loop and 
sneds the correct data to create the output file(s).</p>
<h2>Parameters</h2>
<p>results : python list.
    The results of the vb_cluster_internal_loop.
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
cluster_index : numpy array (M, )
    Array containing the cluster which each vertex belongs to.
output_name : string.
    Name of the output file(s). The default is None.
nib_surf : nibabel object.
    Nibabel object containing metadata to be replicated.
n_items : integer
    How many clusters are.</p>
<h2>Returns</h2>
<p>results_eigenvalues : numpy array (M, )
    Array of the same size as the eigenvectors array but only containing
    the eigenvalue(s).
results_eigenvectors : numpy array (M, 1)
    Array with the same size as the eigenvalues array, each column corresponds
    to each value.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">process_vb_cluster_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">n_items</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-26'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-26'>#</a>
      </div>
      <p>Process results as done in the old code for vb_cluster_internal_loop
Replace the following lines with your specific logic for processing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_index</span><span class="p">)</span>
    <span class="n">midline_index</span> <span class="o">=</span> <span class="n">cluster_index</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">results_v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-27'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-27'>#</a>
      </div>
      <p>results_v2 =  [], <a href="], [.html"></a></p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">results_eigenvectors_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-28'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-28'>#</a>
      </div>
      <p>results_eigenvectors_l =  [], <a href="], [.html"></a>
Save files if output_name is provided</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">rv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">results_v2</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="n">r</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">results_eigenvectors_l</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="n">results_eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surf_vertices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">results_eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_items</span><span class="p">):</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results_eigenvectors_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surf_vertices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_index</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">results_eigenvalues</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">results_v2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">results_eigenvectors_local</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">results_eigenvectors_l</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">results_eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results_eigenvectors_local</span><span class="p">,</span> <span class="n">results_eigenvectors</span><span class="p">)</span>

    <span class="n">results_eigenvectors</span> <span class="o">=</span> <span class="n">results_eigenvectors</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-29'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-29'>#</a>
      </div>
      <p>Remove the midbrain</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">results_eigenvalues</span><span class="p">[</span><span class="n">midline_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">results_eigenvectors</span><span class="p">[</span><span class="n">midline_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_gifti</span><span class="p">(</span><span class="n">nib_surf</span><span class="p">,</span> <span class="n">results_eigenvalues</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">+</span> <span class="s2">&quot;.vb-cluster.value.shape.gii&quot;</span><span class="p">)</span>
        <span class="n">save_gifti</span><span class="p">(</span><span class="n">nib_surf</span><span class="p">,</span> <span class="n">results_eigenvectors</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">+</span> <span class="s2">&quot;.vb-cluster.vector.shape.gii&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results_eigenvalues</span><span class="p">,</span> <span class="n">results_eigenvectors</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-30'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-30'>#</a>
      </div>
      <h2>Parameters</h2>
<p>results : numpy array.
    The results of the vb_cluster_internal_loop.
cort_index : numpy array (M, )
    Mask for detection of middle brain structures.
output_name : string.
    Name of the output file(s).
nib_surf : nibabel object.
    Nibabel object containing metadata to be replicated.</p>
<h2>Returns</h2>
<p>results_v2 : numpy array (M, )
    Array of the computed eigenvalues.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">process_vb_index_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-31'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-31'>#</a>
      </div>
      <p>Process results as done in the old code for vb_index_internal_loop
Replace the following lines with your specific logic for processing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">results_v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">results_v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results_v2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-32'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-32'>#</a>
      </div>
      <p>results = np.array(results)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">results_v2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">cort_index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-33'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-33'>#</a>
      </div>
      <p>The problem is that r is float64, when appending, results_v2 becomes
float64 aswell.
Save files if output_name is provided</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_gifti</span><span class="p">(</span><span class="n">nib_surf</span><span class="p">,</span> <span class="n">results_v2</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">+</span> <span class="s2">&quot;.vbi.shape.gii&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results_v2</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-34'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-34'>#</a>
      </div>
      <h2>Parameters</h2>
<p>results : numpy array
    The results of the vb_hybrid_internal_loop.
cort_index : numpy array (M, )
    Mask for detection of middle brain structures.
output_name : string
    Name of the output file(s).
nib_surf : nibabel object.
    Nibabel object containing metadata to be replicated.
debug : boolean
    Outputs ribbon file for debugging.
data : numpy array (M, N)
    Data to use to calculate the VB index. M must match the number of vertices in the mesh.</p>
<h2>Returns</h2>
<p>processed_results : numpy array
    ??????????</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">process_vb_hybrid_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">cort_index</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">nib_surf</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-35'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-35'>#</a>
      </div>
      <p>Process results as done in the old code for vb_hybrid_internal_loop
Replace the following lines with your specific logic for processing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">processed_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">n_neigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-36'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-36'>#</a>
      </div>
      <p>Save files if output_name is provided</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">save_gifti</span><span class="p">(</span><span class="n">nib_surf</span><span class="p">,</span> <span class="n">processed_results</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">+</span> <span class="s2">&quot;.vbi-hybrid.shape.gii&quot;</span><span class="p">)</span>
        <span class="n">save_gifti</span><span class="p">(</span><span class="n">nib_surf</span><span class="p">,</span> <span class="n">n_neigh</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">+</span> <span class="s2">&quot;.neighbors.shape.gii&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">processed_results</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-37'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-37'>#</a>
      </div>
      <p>Helper function to read the surface from a gifti file.</p>
<h2>Parameters</h2>
<p>filename: string
String containing the name of the file to be opened.</p>
<h2>Returns</h2>
<p>nib: Nibabel object
vertices: (N, 3) numpy vector
          Vertices of the mesh
faces: (M, 3) numoy vector
        Faces of the mesh.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">open_gifti_surf</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-38'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-38'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">nib</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nib</span><span class="p">,</span> <span class="n">nib</span><span class="o">.</span><span class="n">get_arrays_from_intent</span><span class="p">(</span><span class="s1">&#39;pointset&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>  <span class="n">nib</span><span class="o">.</span><span class="n">get_arrays_from_intent</span><span class="p">(</span><span class="s1">&#39;triangle&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-39'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-39'>#</a>
      </div>
      <p>Helper function to read data from a gifti file.</p>
<h2>Parameters</h2>
<p>filename: string
String containing the name of the file to be opened.</p>
<h2>Returns</h2>
<p>nib: Nibabel object
data: (M, N) numpy array
      Data in the file.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">open_gifti</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-40'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-40'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">nib</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-41'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-41'>#</a>
      </div>
      <p>We use the first data as this is agnostic to the intent. In the future we
might want to change it.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">return</span> <span class="n">nib</span><span class="p">,</span> <span class="n">nib</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-42'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-42'>#</a>
      </div>
      <p>Helper function to write data into a gifti file.</p>
<h2>Parameters</h2>
<p>og_img: Nibabel object
data: (M, N) numpy array
      Data to write into the file. M must math the number of vertices in the mesh
filename: string
          String containing the name of the file to be saved</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">save_gifti</span><span class="p">(</span><span class="n">og_img</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-43'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-43'>#</a>
      </div>
      <p>For some reason, wc_view demands float32</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">data_array</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiDataArray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-44'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-44'>#</a>
      </div>
      <p>Create a meta object containing the cortex information</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="s1">&#39;AnatomicalStructurePrimary&#39;</span> <span class="ow">in</span> <span class="n">og_img</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
        <span class="n">new_meta</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiMetaData</span><span class="p">(</span><span class="n">AnatomicalStructurePrimary</span><span class="o">=</span><span class="n">og_img</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;AnatomicalStructurePrimary&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_meta</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiMetaData</span><span class="p">()</span>
    <span class="n">new_nib</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiImage</span><span class="p">(</span><span class="n">darrays</span><span class="o">=</span><span class="p">[</span><span class="n">data_array</span><span class="p">],</span> <span class="n">meta</span><span class="o">=</span><span class="n">new_meta</span><span class="p">)</span>

    <span class="n">nibabel</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">new_nib</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

<span class="n">counter</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">n</span> <span class="o">=</span> <span class="kc">None</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Lock</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-45'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-45'>#</a>
      </div>
      <p>Store total number of vertices and counter of vertices computed</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">a_counter</span><span class="p">,</span> <span class="n">a_n</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-46'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-46'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">global</span> <span class="n">counter</span>
    <span class="k">global</span> <span class="n">n</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">a_counter</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a_n</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-47'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-47'>#</a>
      </div>
      <p>Objetivo: calcular el indice vogt bailey en una malla</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">vb_index_internal_loop</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-48'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-48'>#</a>
      </div>
      <p>Computes the Vogt-Bailey index of vertices in a given range</p>
<p>Parameters</p>
<hr />
<p>i0: integer
       Index of first vertex to be analysed
   iN: integer
       iN - 1 is the index of the last vertex to be analysed
   surf_faces: (M, 3) numpy array
       Faces of the mesh. Used to find the neighborhood of a given vertex
   data: (M, N) numpy array
       Data to use to calculate the VB index. M must match the number of vertices in the mesh
   norm: string
       Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;
   print_progress: boolean
       Print the current progress of the system</p>
<p>Returns</p>
<hr />
<p>loc_result: (N) numpy array
               Resulting VB index of the indices in range. Will have length iN - i0</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-49'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-49'>#</a>
      </div>
      <p>Calculate how many vertices we will compute</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">diff</span> <span class="o">=</span> <span class="n">iN</span> <span class="o">-</span> <span class="n">i0</span> <span class="c1"># Estos determinan el rango de vertices que seran analizados</span>
    <span class="n">loc_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># Se hace una matriz de 0 teniendo en cuenta el rango de los vertices</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-50'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-50'>#</a>
      </div>
      <p>Calculate the real index</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">i0</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-51'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-51'>#</a>
      </div>
      <p>Get neighborhood and its data
TODO: Make this elegant</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">try</span><span class="p">:</span>
            <span class="n">neighbor_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">surf_faces</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">surf_faces</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="c1"># Va iterando por cada vertice y mira si tiene vecinos</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: no neighborhood for vertex:&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Si no tiene que pone que no tiene y le ponen un NaN</span>
                <span class="k">continue</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-52'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-52'>#</a>
      </div>
      <p>Calculate the second smallest eigenvalue</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="n">affinity</span> <span class="o">=</span> <span class="n">create_affinity_matrix</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span> <span class="c1"># Crea la matriz de afinidad para poder sacar luego el eigenvalue </span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spectral_reorder</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">affinity</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span> <span class="c1"># Calcula el segundo valor mas pequeno del eigenvalue que te dice el grado</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-53'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-53'>#</a>
      </div>
      <p>return [0]
Store the result of this run</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenvalue</span> <span class="c1"># El resultado de va a terminar siendo el eigenvalue</span>
        <span class="k">except</span> <span class="n">TimeSeriesTooShortError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span> 
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Simplemente gestiona errores</span>

        <span class="k">if</span> <span class="n">print_progress</span><span class="p">:</span> <span class="c1"># Esto es un input para que si esta en True te va printeando info, supongo que para debguear</span>

            <span class="k">global</span> <span class="n">counter</span>
            <span class="k">global</span> <span class="n">n</span>
            <span class="k">with</span> <span class="n">counter</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
                <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">loc_result</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-54'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-54'>#</a>
      </div>
      <p>Computes the Vogt-Bailey index and Fiedler vector of vertices of given clusters</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">vb_cluster_internal_loop</span><span class="p">(</span><span class="n">full_brain</span><span class="p">,</span> <span class="n">idx_cluster_0</span><span class="p">,</span> <span class="n">idx_cluster_N</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-55'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-55'>#</a>
      </div>
      <p>Parameters</p>
<hr />
<p>idx_cluster_0: integer
       Index of first cluster to be analysed
   idx_cluster_N: integer
       idx_cluster_N - 1 is the index of the last cluster to be analysed
   surf_faces: (M, 3) numpy array
       Faces of the mesh. Used to find the neighborhood of a given vertex
   data: (M, N) numpy array
       Data to use to calculate the VB index and Fiedler vector. M must match the number of vertices in the mesh
   cluster_index: (M) numpy array
       Array containing the cluster which each vertex belongs to
   norm: string
       Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;
   print_progress: boolean
       Print the current progress of the system</p>
<p>Returns</p>
<hr />
<p>loc_result: list of pairs of (float, (N) numpy array)
               Resulting VB index and Fiedler vector for each of the clusters in range</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">diff</span> <span class="o">=</span> <span class="n">idx_cluster_N</span> <span class="o">-</span> <span class="n">idx_cluster_0</span>
    <span class="n">loc_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="n">diff</span><span class="o">+</span><span class="mi">1</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_index</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-56'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-56'>#</a>
      </div>
      <p>Calculate the real index</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">idx_cluster_0</span>

        <span class="k">if</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-57'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-57'>#</a>
      </div>
      <p>loc_result.append(([], []))
This line was commented because it makes no sense to fill
a result variable with empty arrays</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-58'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-58'>#</a>
      </div>
      <p>Get neighborhood and its data</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cluster_index</span> <span class="o">==</span> <span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-59'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-59'>#</a>
      </div>
      <p>Calculate the Fiedler eigenpair</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="n">affinity</span> <span class="o">=</span> <span class="n">create_affinity_matrix</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">spectral_reorder</span><span class="p">(</span><span class="n">full_brain</span><span class="p">,</span> <span class="n">affinity</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-60'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-60'>#</a>
      </div>
      <p>Store the result of this run
Warning: It is not true that the eigenvectors will be all the same
size, as the clusters might be of different sizes
val = eigenvalue
vel = eigenvector
loc_result.append((val, vel))</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>            <span class="n">loc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenvalue</span>
            <span class="n">loc_result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenvector</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-61'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-61'>#</a>
      </div>
      <p>lr_1[idx] = val
lr_2[idx] = vel</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">except</span> <span class="n">TimeSeriesTooShortError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>


        <span class="k">if</span> <span class="n">print_progress</span><span class="p">:</span>

            <span class="k">global</span> <span class="n">counter</span>
            <span class="k">global</span> <span class="n">n</span>
            <span class="k">with</span> <span class="n">counter</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
                <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">loc_result</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-62'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-62'>#</a>
      </div>
      <p>Get neighbors in volumetric space given the coordinates of a vertex</p>
<h2>Parameters</h2>
<p>data : (M, N) numpy array
    Data to use to calculate the VB index and Fiedler vector. M must match the number of vertices in the mesh
surf_vertices : numpy array (M, 3)
    Vertices of the mesh.
surf_faces : (M, 3) numpy array
    Faces of the mesh. Used to find the neighborhood of a given vertex.
i : integer
    Index of the vertex.
affine : ????????
    ?????????
k : integer
    Factor determining increase in density of input mesh (default k=3)
debug : boolean, optional.
    Outputs ribbon file for debugging (default = False)</p>
<h2>Returns</h2>
<p>????????
    ??????????.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">get_neighborhood</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-63'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-63'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-64'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-64'>#</a>
      </div>
      <p>Step 1: Find indices of faces containing vertex i</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">neighbor_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">surf_faces</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">surf_faces</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">,</span> <span class="p">:])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-65'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-65'>#</a>
      </div>
      <p>Step 2: Generate new vertices in the neighborhood</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">surf_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">k</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">i</span><span class="p">)])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-66'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-66'>#</a>
      </div>
      <p>Step 3: Combine original and new vertices to create a dense neighborhood</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">dense_neigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">I</span><span class="p">],</span> <span class="n">new_v</span><span class="p">])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-67'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-67'>#</a>
      </div>
      <p>Step 4: Transform dense neighborhood coordinates to voxel space</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nibabel</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">affine</span><span class="p">),</span> <span class="n">dense_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-68'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-68'>#</a>
      </div>
      <p>Step 5: Transform vertex coordinates to voxel space</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">v_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nibabel</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">affine</span><span class="p">),</span> <span class="n">surf_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-69'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-69'>#</a>
      </div>
      <p>Step 6: Create a cube of voxel coordinates around the vertex</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">v_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">relative_index</span> <span class="k">for</span> <span class="n">relative_index</span> <span class="ow">in</span> <span class="n">product</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">)])</span> <span class="o">+</span> <span class="n">v_map</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-70'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-70'>#</a>
      </div>
      <p>Step 7: Filter out unique voxel coordinates that are within the cube</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">neigh_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">v_cube</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-71'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-71'>#</a>
      </div>
      <p>Step 8: Check if the neighborhood is too small and add second-ring neighbors</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh_coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">I</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">I</span><span class="p">:</span>
            <span class="n">neighbor_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">surf_faces</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">surf_faces</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-72'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-72'>#</a>
      </div>
      <p>Step 9: Generate new vertices for the second ring of neighbors</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">surf_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">k</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">i</span><span class="p">)])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-73'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-73'>#</a>
      </div>
      <p>Step 10: Combine original and new vertices for the second ring</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">dense_neigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">surf_vertices</span><span class="p">[</span><span class="n">neighbors</span><span class="p">],</span> <span class="n">new_v</span><span class="p">])</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-74'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-74'>#</a>
      </div>
      <p>Step 11: Transform second-ring neighborhood coordinates to voxel space</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nibabel</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">affine</span><span class="p">),</span> <span class="n">dense_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-75'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-75'>#</a>
      </div>
      <p>Step 12: Filter out unique voxel coordinates that are within the cube</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">neigh_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">v_cube</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-76'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-76'>#</a>
      </div>
      <p>Step 13: If in debug mode, return neighborhood data and coordinates</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:],</span> <span class="n">neigh_coords</span>
    <span class="k">else</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-77'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-77'>#</a>
      </div>
      <p>Step 14: Otherwise, return neighborhood data only</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">neigh_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-78'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-78'>#</a>
      </div>
      <p>Computes the Vogt-Bailey index of vertices in a given range</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">vb_hybrid_internal_loop</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">surf_vertices</span><span class="p">,</span> <span class="n">surf_faces</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-79'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-79'>#</a>
      </div>
      <p>Parameters</p>
<hr />
<p>i0: integer
       Index of first vertex to be analysed
   iN: integer
       iN - 1 is the index of the last vertex to be analysed
   surf_vertices: (M, 3) numpy array
       Coordinates of vertices of the mesh in voxel space
   brain_mask: (nRows, nCols, nSlices) numpy array
       Whole brain mask. Used to mask volumetric data
   data: (nRows, nCols, nSlices, N) numpy array
       Volumetric data used to calculate the VB index. N is the number of maps
   norm: string
       Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;
   k: integer
       Factor determining increase in density of input mesh (default k=3)
   debug: boolean
       Outputs ribbon file for debugging
   print_progress: boolean
       Print the current progress of the system</p>
<p>Returns</p>
<hr />
<p>loc_result: (N) numpy array
               Resulting VB index of the indices in range. Will have length iN - i0</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-80'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-80'>#</a>
      </div>
      <p>Calculate how many vertices we will compute</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">diff</span> <span class="o">=</span> <span class="n">iN</span> <span class="o">-</span> <span class="n">i0</span>
    <span class="n">loc_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="n">loc_neigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="n">all_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>


    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-81'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-81'>#</a>
      </div>
      <p>Calculate the real index</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">i0</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-82'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-82'>#</a>
      </div>
      <p>Get neighborhood and its data</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">neighborhood</span><span class="p">,</span> <span class="n">neigh_coords</span> <span class="o">=</span> <span class="n">get_neighborhood</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">surf_vertices</span><span class="p">,</span><span class="n">surf_faces</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">affine</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">all_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">all_coords</span><span class="p">,</span><span class="n">neigh_coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">get_neighborhood</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">surf_vertices</span><span class="p">,</span><span class="n">surf_faces</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">affine</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="n">to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1e-10</span><span class="p">)</span>
            <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">[</span><span class="n">to_keep</span><span class="p">,:])</span>
            <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>
            <span class="n">loc_neigh</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: no neighborhood for vertex:&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>
            <span class="n">affinity</span> <span class="o">=</span> <span class="n">create_affinity_matrix</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">affinity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-83'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-83'>#</a>
      </div>
      <p>Calculate the second smallest eigenvalue</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spectral_reorder</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">affinity</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
                <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenvalue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: too few neighbors (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">affinity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;for vertex:&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">except</span> <span class="n">TimeSeriesTooShortError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="n">loc_result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        

        <span class="k">if</span> <span class="n">print_progress</span><span class="p">:</span>

            <span class="k">global</span> <span class="n">counter</span>
            <span class="k">global</span> <span class="n">n</span>
            <span class="k">with</span> <span class="n">counter</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
                <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">loc_result</span><span class="p">,</span> <span class="n">loc_neigh</span><span class="p">,</span> <span class="n">all_coords</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">loc_result</span><span class="p">,</span> <span class="n">loc_neigh</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-84'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-84'>#</a>
      </div>
      <p>Raised when the time series in the input data have less than three elements</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">class</span> <span class="nc">TimeSeriesTooShortError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-85'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-85'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">pass</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-86'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-86'>#</a>
      </div>
      <p>Force the symmetry of a given matrix.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">force_symmetric</span><span class="p">(</span><span class="n">M</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-87'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-87'>#</a>
      </div>
      <p>The symmetric version is computed by first replicating the diagonal and
upper triangular components of the matrix, and mirroring the upper diagonal
into the lower diagonal them into the lower triangular.</p>
<h2>Parameters</h2>
<p>M: (N, N) numpy array
   Matrix to be made symmetric</p>
<h2>Returns</h2>
<p>M_sym: Symmetric version of M</p>
<p>One diag extracts the diagonal into an array, two
diags turns the array into a diagonal matrix.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">diag_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
    <span class="n">triu_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">triu_M</span> <span class="o">+</span> <span class="n">diag_M</span> <span class="o">+</span> <span class="n">triu_M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-88'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-88'>#</a>
      </div>
      <p>Solve the general eigenproblem to find the Fiedler vector and the corresponding eigenvalue.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">get_fiedler_eigenpair</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">full_brain</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="s1">&#39;def_tol&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-89'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-89'>#</a>
      </div>
      <p>Solves the general eigenproblem Qx = lambda*Dx, and returns the Fiedler vector and associated eigenvalue. 
The former is unitary in the norm induced by the matrix D. If D is not set, the identity matrix is assumed.</p>
<h2>Parameters</h2>
<p>Q: (M, M) numpy array
   Main matrix
D: (M, M) numpy array
   Matrix that accounts for node degree bias. If not set, this function will solve the
   standard eigenproblem (Qx = lambda<em>x)
is_symmetric: boolean
              Indicates whether Q </em>and* D are symmetric. If set, the program will use a 
              much faster, but less general, algorithm</p>
<h2>Returns</h2>
<p>second_smallest_eigval: floating-point number
                     The second smallest eigenvalue
fiedler_vector: (M) numpy array
                The Fiedler vector</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">if</span> <span class="n">is_symmetric</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full_brain</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">tol_standard</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-15</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tol</span> <span class="o">==</span> <span class="s1">&#39;def_tol&#39;</span><span class="p">:</span>
                <span class="n">tol</span> <span class="o">=</span> <span class="n">tol_standard</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">lobpcg</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbosityLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">retLambdaHistory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retResidualNormsHistory</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
          
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
    <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">)</span>
    
    <span class="n">sort_eigen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span><span class="p">[</span><span class="n">sort_eigen</span><span class="p">]</span>
    
    <span class="n">dim</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;unnorm&#39;</span><span class="p">:</span>
        <span class="n">normalisation_factor</span> <span class="o">=</span> <span class="n">dim</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">normalisation_factor</span> <span class="o">=</span> <span class="n">dim</span><span class="o">/</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>

    <span class="n">second_smallest_eigval</span> <span class="o">=</span> <span class="n">eigenvalues</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normalisation_factor</span>
    <span class="n">second_smallest_eigval</span> <span class="o">=</span> <span class="n">second_smallest_eigval</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">fiedler_vector</span> <span class="o">=</span> <span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">sort_eigen</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">fiedler_vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">fiedler_vector</span><span class="p">))</span>
    <span class="n">fiedler_vector</span> <span class="o">=</span> <span class="n">fiedler_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">second_smallest_eigval</span><span class="p">,</span> <span class="n">fiedler_vector</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-90'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-90'>#</a>
      </div>
      <p>Computes the spectral reorder of the matrix B</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">spectral_reorder</span><span class="p">(</span><span class="n">full_brain</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">max_num_iter</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;unnorm&#39;</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-91'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-91'>#</a>
      </div>
      <h2>Parameters</h2>
<p>B: (M, M) array_like
   Square matrix to be reordered
method: string
        Method of reordering. Possibilities are &lsquo;geig&rsquo;, &lsquo;unnorm&rsquo;, &lsquo;rw&rsquo; and &lsquo;sym&rsquo;</p>
<h2>Returns</h2>
<p>sorted_B: (M, M) numpy array
          Reordered matrix
sort_idx: (M) numpy array
          Reordering mask applied to B
eigenvalue: floating-point number
            Second-smallest eigenvalue
eigenvector: (M) numpy array
             The Fiedler vector</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-92'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-92'>#</a>
      </div>
      <p>Fix the input</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Matrix B must be square!&quot;</span>

    <span class="n">min_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">min_b</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;This function only accepts matrices with a mininum negative value of -1&quot;</span>

    <span class="k">if</span> <span class="n">min_b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        The value 1 is being added to your similarity matrix to ensure positivity.</span>
<span class="s2">        This may cause issues with interpretation. Consider inputing a positive matrix&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">UserWarning</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">B</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-93'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-93'>#</a>
      </div>
      <p>Actual decomposition</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-94'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-94'>#</a>
      </div>
      <p>create the laplacian matrix (Q).
For all non-diagonal elements, populate matrix Q with (minus) the corresponding
values of matrix C (i.e. Q[i,j] = -C[i,j]).
For each diagonal element Q[i,i], sum across the corresponding row of C (excluding the
diagonal element C[i,i]) and set Q[i,i] equal to that sum. </p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>    <span class="n">triuC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Extract upper triangular elements;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">triuC</span> <span class="o">+</span> <span class="n">triuC</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># Reconstruct a symmetric weighted adjacency matrix eliminating possible small errors in off-diagonal elements</span>
    <span class="n">D</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># Compute the Degree matrix</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">C</span><span class="p">;</span> <span class="c1"># Compute un-normalised Laplacian</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;geig&#39;</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-95'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-95'>#</a>
      </div>
      <p>Method using generalised spectral decomposition of the
un-normalised Laplacian (see Shi and Malik, 2000)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">get_fiedler_eigenpair</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">full_brain</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_num_iter</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sym&#39;</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-96'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-96'>#</a>
      </div>
      <p>Method using the eigen decomposition of the Symmetric Normalized
Laplacian. Note that results should be the same as &lsquo;geig&rsquo;</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1">#Compute the normalized laplacian</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">force_symmetric</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="c1"># Force symmetry</span>

        <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">get_fiedler_eigenpair</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">full_brain</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_num_iter</span><span class="p">)</span>
        <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eigenvector</span><span class="p">)</span> <span class="c1"># automatically normalized (i.e. eigenvector.transpose() @ (D @ eigenvector) = 1)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rw&#39;</span><span class="p">:</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-97'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-97'>#</a>
      </div>
      <p>Method using eigen decomposition of Random Walk Normalised Laplacian</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>        <span class="n">L</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

        <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">get_fiedler_eigenpair</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">full_brain</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_num_iter</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">eigenvector</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">eigenvector</span><span class="p">))</span>
        <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">eigenvector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;unnorm&#39;</span><span class="p">:</span>

        <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span> <span class="o">=</span> <span class="n">get_fiedler_eigenpair</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">full_brain</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">residual_tolerance</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_num_iter</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Method &#39;</span><span class="si">{}</span><span class="s2">&#39; not allowed. </span><span class="se">\n</span><span class="s2"></span>
<span class="s2">        Please choose one of the following: &#39;sym&#39;, &#39;rw&#39;, &#39;geig&#39;, &#39;unnorm&#39;.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

    <span class="n">v2</span> <span class="o">=</span> <span class="n">eigenvector</span> <span class="c1"># Fiedler vector</span>
    <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="c1"># Find the reordering index</span>
    <span class="n">sorted_B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">,:]</span> <span class="c1"># Reorder the original matrix</span>
    <span class="n">sorted_B</span> <span class="o">=</span> <span class="n">sorted_B</span><span class="p">[:,</span><span class="n">sort_idx</span><span class="p">]</span> <span class="c1"># Reorder the original matrix</span>

    <span class="k">return</span> <span class="n">sorted_B</span><span class="p">,</span> <span class="n">sort_idx</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="p">,</span> <span class="n">eigenvector</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-98'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-98'>#</a>
      </div>
      <h1>The following line is necessary for when neighborhood is an (M,) array (i.e. it is 1D), in</h1>
<h1>which case it is converted to an (M,1) array.</h1>
<p>neighborhood = np.atleast_2d(neighborhood)</p>
<h1>Here, the affinity matrix should have n_neighbors x data_size shape</h1>
<p>if neighborhood.shape[1] &lt; 3:
    raise TimeSeriesTooShortError(&ldquo;Time series have less than 3 entries. Your analysis will be compromised!\n&rdquo;)</p>
<h1>Create a mean centered neighborhood</h1>
<p>neighborhood_mean = np.mean(neighborhood, axis=-1)
neighborhood_mc = neighborhood - neighborhood_mean.reshape(-1, 1)
neighborhood_mc[np.abs(neighborhood_mc)&lt;eps] = eps</p>
<p>if verbose:
    print(&ldquo;neighborhood_mean&rdquo;)
    print(neighborhood_mean)</p>
<pre><code>print("neighborhood_mc")
print(neighborhood_mc)
</code></pre>
<h1>Normalise the mean centered neighborhood</h1>
<p>neighborhood_w = np.sqrt(np.sum(neighborhood_mc**2, axis=-1)).reshape(-1, 1)
neighborhood_scaled = neighborhood_mc/neighborhood_w</p>
<p>affinity = np.dot(neighborhood_scaled, neighborhood_scaled.transpose())
affinity[affinity &gt; 1.0] = 1.0
affinity[affinity &lt; -1.0] = -1.0</p>
<h1>&ldquo;Linearlise&rdquo; the affinity ensure positive correlations are between 0 to 1</h1>
<h1>what i am doing here is to change cosines to angles but to ensure that</h1>
<h1>this remains a similarity rather than dissimilarity I am treating the</h1>
<h1>values as the sine rather than cosine. I.e. identical signals will be 90</h1>
<h1>rather than 0. 90/90 == 1.</h1>
<p>A = np.arcsin(affinity)/np.pi*180.0
A = A/90.0</p>
<h1>Remove negative correlations</h1>
<p>A[A&lt;0] = eps</p>
<p>if verbose:
    print(&ldquo;affinity&rdquo;)
    print(affinity)
    print(&ldquo;A&rdquo;)
    print(A)</p>
<p>return A</p>
<p>class MultilineFormatter(argparse.HelpFormatter):
def _fill_text(self, text, width, indent):
    text = self._whitespace_matcher.sub(&rsquo; &lsquo;, text).strip()
    paragraphs = text.split(&lsquo;|n &lsquo;)
    multiline_text = &lsquo;&rsquo;
    for paragraph in paragraphs:
        formatted_paragraph = _textwrap.fill(paragraph, width, initial_indent=indent, subsequent_indent=indent) + &lsquo;\n\n&rsquo;
        multiline_text = multiline_text + formatted_paragraph
    return multiline_text</p>
<p>def create_parser():
authors = &lsquo;&rsquo;&lsquo;authors:
|n   The VB Index Team (See Contributors Section in the main README)&rsquo;&lsquo;&rsquo;
copyright = &lsquo;&rsquo;&lsquo;copyright:|n
    This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.|n
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.|n
You should have received a copy of the GNU General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses">https://www.gnu.org/licenses</a>.
&lsquo;&rsquo;&rsquo;
references = &lsquo;&rsquo;&lsquo;references:|n
    Bajada, C. J., Campos, L. Q. C., Caspers, S., Muscat, R., Parker, G. J., Ralph, M. A. L., &hellip; &amp; Trujillo-Barreto, N. J. (2020). A tutorial and tool for exploring feature similarity gradients with MRI data. NeuroImage, 221, 117140.|n
    Ciantar, K. G., Farrugia, C., Scerri, K., Xu, T., &amp; Bajada, C. J. (2020). Geometric effects of volume-to-surface mapping of fMRI data. bioRxiv.
&lsquo;&rsquo;&lsquo;</p>
<p>parser = argparse.ArgumentParser(description=&rsquo;Calculate the Vogt-Bailey index of a dataset. For more information, refer to https://github.com/VBIndex/py_vb_toolbox.&rsquo;,
                                 epilog=authors + &rdquo; |n &rdquo; + references + &rdquo; |n &rdquo; + copyright,
                                 formatter_class=MultilineFormatter)
parser.add_argument(&lsquo;-j&rsquo;, &lsquo;&ndash;jobs&rsquo;, metavar=&rsquo;N&rsquo;, type=int, nargs=1,
                    default=[multiprocessing.cpu_count()], help=&rdquo;&ldquo;&rdquo;Maximum
                    number of jobs to be used. If absent, one job per CPU
                    will be spawned.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-n&rsquo;, &lsquo;&ndash;norm&rsquo;, metavar=&rsquo;norm&rsquo;, type=str, nargs=1,
                    help=&rdquo;&ldquo;&rdquo;Laplacian normalization to be
                    employed. Possibilities are &ldquo;geig&rdquo;, &ldquo;unnorm&rdquo;, &ldquo;rw&rdquo; and
                    &ldquo;sym&rdquo;. Defaults to geig for the full brain and ROI analyses, and to unnorm otherwise.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-fb&rsquo;, &lsquo;&ndash;full-brain&rsquo;, action=&rsquo;store_true&rsquo;,
                    help=&rdquo;&ldquo;&rdquo;Calculate full brain feature gradient analysis.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-hy&rsquo;, &lsquo;&ndash;hybrid&rsquo;, action=&rsquo;store_true&rsquo;,
                    help=&rdquo;&ldquo;&rdquo;Calculate searchlight VB index with hybrid approach.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-m&rsquo;, &lsquo;&ndash;mask&rsquo;, metavar=&rsquo;file&rsquo;, type=str,
                           nargs=1, help=&rdquo;&ldquo;&rdquo;File containing the labels to
                           identify the cortex, rather than the medial
                           brain structures. This flag must be set for
                           the searchlight and full brain analyses.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-c&rsquo;, &lsquo;&ndash;clusters&rsquo;, metavar=&rsquo;file&rsquo;, type=str, nargs=1, default=None,
                    help=&rdquo;&ldquo;&rdquo;File specifying the surface clusters. The cluster
                    with index 0 is expected to denote the medial brain
                    structures and will be ignored.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-t&rsquo;, &lsquo;&ndash;tol&rsquo;, metavar=&rsquo;tolerance&rsquo;, type=float, nargs=1,
                    default=[&ldquo;def_tol&rdquo;], help=&rdquo;&ldquo;&rdquo;Residual tolerance (stopping criterion) for LOBPCG. 
                    Default value = sqrt(10e-18)*n, where n is the number of nodes per graph. Note that
                    the LOBPCG algorithm is only utilised for full-brain analysis.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-mi&rsquo;, &lsquo;&ndash;maxiter&rsquo;, metavar=&rsquo;max iterations&rsquo;, type=int, nargs=1, default=[50],
                    help=&rdquo;&ldquo;&rdquo;Maximum number of iterations for LOBPCG. Defaults to 50.&rdquo;&ldquo;&rdquo;)</p>
<p>parser.add_argument(&lsquo;-debug&rsquo;, &lsquo;&ndash;debug&rsquo;, action=&rsquo;store_true&rsquo;,
                    help=&rdquo;&ldquo;&rdquo;Save additional files for debugging.&rdquo;&ldquo;&rdquo;)</p>
<p>requiredNamed = parser.add_argument_group(&lsquo;required named arguments&rsquo;)</p>
<p>requiredNamed.add_argument(&lsquo;-s&rsquo;, &lsquo;&ndash;surface&rsquo;, metavar=&rsquo;file&rsquo;, type=str,
                           nargs=1, help=&rdquo;&ldquo;&rdquo;File containing the surface
                                          mesh.&rdquo;&ldquo;&rdquo;, required=True)</p>
<p>requiredNamed.add_argument(&lsquo;-d&rsquo;, &lsquo;&ndash;data&rsquo;, metavar=&rsquo;file&rsquo;, type=str,
                           nargs=1, help=&rdquo;&ldquo;&rdquo;File containing the data over
                                          the surface (or volume if hybrid).&rdquo;&ldquo;&rdquo;, required=True)</p>
<p>requiredNamed.add_argument(&lsquo;-o&rsquo;, &lsquo;&ndash;output&rsquo;, metavar=&rsquo;file&rsquo;, type=str,
                           nargs=1, help=&rdquo;&ldquo;&rdquo;Base name for the
                                          output files.&rdquo;&ldquo;&rdquo;, required=True)</p>
<p>return parser</p>
<p>def main():</p>
<p>parser = create_parser()
args = parser.parse_args()</p>
<p>n_cpus = args.jobs[0]
nib_surf, vertices, faces = open_gifti_surf(args.surface[0])</p>
<h1>Get the text contents from the file</h1>
<p>surf_text = open(args.surface[0], &lsquo;r&rsquo;, encoding=&rsquo;latin-1&rsquo;)</p>
<p>hemi = None</p>
<h1>Check whether the file is left or right cortex</h1>
<p>for line in surf_text:
    if &lsquo;CortexLeft&rsquo; in line:
        hemi = &lsquo;CortexLeft&rsquo;
        break
    elif &lsquo;CortexRight&rsquo; in line:
        hemi = &lsquo;CortexRight&rsquo;
        break</p>
<h1>Add the cortex information to the meta data</h1>
<p>if hemi:
    nib_surf.meta[&lsquo;AnatomicalStructurePrimary&rsquo;] = hemi</p>
<p>nib = nibabel.load(args.data[0])
if args.hybrid:
    data = np.array(nib.dataobj)
    affine = nib.affine
else:
    if len(nib.darrays) &gt; 1:
        data = np.array([n.data for n in nib.darrays]).transpose()
    else:
        data = nib.darrays[0].data</p>
<p>if (args.norm is not None and args.norm[0] == &lsquo;rw&rsquo;):
    print(&lsquo;Warning: this method makes use of the Random Walk Normalized Laplacian, and has not been tested rigorously yet.&rsquo;)
if (args.norm is not None and args.norm[0] == &lsquo;sym&rsquo;):
    print(&lsquo;Warning: this method makes use of the Symmetric Normalized Laplacian, and has not been tested rigorously yet.&rsquo;)</p>
<p>if args.full_brain:
    print(&ldquo;Running full brain analysis&rdquo;)
    if args.mask is None:
        sys.stderr.write(&ldquo;A mask file must be provided through the &ndash;mask flag. See &ndash;help&rdquo;)
        sys.exit(2)
        quit()
    # Read labels
    _, labels = open_gifti(args.mask[0])
    cort_index = np.array(labels, bool)
    Z = np.array(cort_index, dtype=int)
    if args.norm is None:
        L_norm = &lsquo;geig&rsquo;
    else:
        L_norm = args.norm[0]
    try:
        result = compute_vb_metrics(&ldquo;vb_cluster&rdquo;, surf_vertices=vertices, surf_faces=faces, n_cpus=n_cpus, data=data, norm=L_norm, residual_tolerance=args.tol[0], max_num_iter=args.maxiter[0], output_name=args.output[0] + &ldquo;.&rdquo; + L_norm, nib_surf=nib_surf, cluster_index=Z, debug=args.debug)
        #full_brain=True
    except Exception as error:
        sys.stderr.write(str(error))
        sys.exit(2)
        quit()</p>
<p>elif args.clusters is None:
    if args.hybrid:
        print(&ldquo;Running searchlight analysis with hybrid approach&rdquo;)
        if args.mask is None:
            sys.stderr.write(&ldquo;A mask file must be provided through the &ndash;mask flag. See &ndash;help&rdquo;)
            sys.exit(2)
            quit()</p>
<pre><code>    # Read labels
    _, labels = open_gifti(args.mask[0])
    cort_index = np.array(labels, bool)
    if args.norm is None:
        L_norm = 'unnorm'
    else:
        L_norm = args.norm[0]
    try:
        result = compute_vb_metrics("vb_hybrid", surf_vertices=vertices, surf_faces=faces, affine=affine, n_cpus=n_cpus, data=data, norm=L_norm, cort_index=cort_index, residual_tolerance=args.tol[0], max_num_iter=args.maxiter[0], output_name="hybrid_approche_output", nib_surf=nib_surf, k=3, debug=args.debug)
    except Exception as error:
        sys.stderr.write(str(error))
        sys.exit(2)
        quit()
else:
    print("Running searchlight analysis")
    if args.mask is None:
        sys.stderr.write("A mask file must be provided through the --mask flag. See --help")
        sys.exit(2)
        quit()
    # Read labels
    _, labels = open_gifti(args.mask[0])
    cort_index = np.array(labels, bool)
    if args.norm is None:
        L_norm = 'unnorm'
    else:
        L_norm = args.norm[0]
    try:
        result = compute_vb_metrics("vb_index", surf_vertices=vertices, surf_faces=faces, n_cpus=n_cpus, data=data, norm=L_norm, cort_index=cort_index, residual_tolerance=args.tol[0], max_num_iter=args.maxiter[0], output_name=args.output[0] + "." + L_norm, nib_surf=nib_surf)
    except Exception as error:
        sys.stderr.write(str(error))
        sys.exit(2)
        quit()
</code></pre>
<p>else:
    print(&ldquo;Running ROI analysis&rdquo;)
    if args.clusters is None:
        sys.stderr.write(&ldquo;A cluster file must be provided through the &ndash;clusters flag. See &ndash;help&rdquo;)
        sys.exit(2)
        quit()
    nib, Z = open_gifti(args.clusters[0])
    Z = np.array(Z, dtype=np.int)
    if args.norm is None:
        L_norm = &lsquo;geig&rsquo;
    else:
        L_norm = args.norm[0]
    try:
        result = compute_vb_metrics(&ldquo;vb_cluster_internal_loop&rdquo;, False, vertices, faces, n_cpus, data, L_norm, args.tol[0], args.maxiter[0], args.output[0] + &ldquo;.&rdquo; + L_norm, nib_surf, k=3, cluster_index=Z, cort_index=cort_index, affine=affine, debug=args.debug)
    except Exception as error:
        sys.stderr.write(str(error))
        sys.exit(2)
        quit()</p>
<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
main()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">create_affinity_matrix</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Computes the affinity matrix of a given neighborhood</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    neighborhood: (M, N) numpy array</span>
<span class="s2">    eps: float</span>
<span class="s2">         Small value which will replace negative numbers</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    affinity: (M, M) numpy array</span>
<span class="s2">              Affinity matrix of the neighborhood</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
